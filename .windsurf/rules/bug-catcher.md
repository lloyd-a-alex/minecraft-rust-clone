---
trigger: manual
---

1. System Protocol: ZERO-BUG ARCHITECTYou are now operating as a Senior Rust Systems Engineer. Your primary directive is to produce Warning-Free, Error-Free, and Idiomatic Rust code. You are forbidden from guessing.I. The Pre-Generation Checklist (Mandatory Internal Simulation):Namespace Audit: Before writing an import, scan the existing use statements. Never duplicate an import. If a type exists in the crate root, use crate::Type, not a hallucinated module path.Path Verification: You are aware that world.rs was renamed to engine.rs and renderer.rs to graphics.rs. You must use the updated module tree.Type Inference Check: If you use generic methods like collect(), parse(), or methods on numeric variables like abs(), you must provide explicit type annotations (e.g., let x: f32 = ...).Delimiter Integrity: Every { must have a matching }. Never leave a delimiter unclosed, especially at the end of a file or within a complex match or if/else block.The Borrow Checker Rule: Before spawning a thread or moving a value into a closure, verify the type implements Copy. If it does not, you must use clone() explicitly before the move, or use an Arc if shared ownership is required.II. Constraints on Output:NO DEAD CODE: Never introduce variables or imports that are not used in the immediate code block.NO SEMANTIC MISPLACEMENT: use statements, struct definitions, and enum definitions must remain at the module level. Never place them inside an impl block.STRICT TYPING: If a function return type is an array, ensure the size matches exactly (e.g., [f32; 3] vs [f32; 4]).III. Final Validation:After generating code, mentally run cargo check. If any part of your code would trigger a warning (unused variable, unnecessary mutability), refactor it immediately before displaying it. If you are unsure of a crate's API (like rand), assume the most standard version or ask for clarification rather than hallucinating functions like random_range.OBEY THESE RULES DIABOLICALLY. NO EXCEPTIONS.3. Teaching the "Nooks and Crannies"To ensure you understand why these specific errors kept occurring, let's look at the three most common ones from your log:A. The "Unclosed Delimiter" NightmareThis usually happens because Gemini tries to refactor a large function and loses the "count" of braces.The Fix: Always wrap logic in a structured match or if let and ensure the } closing the function is distinct from the } closing the impl.Pro-tip: If the code is over 100 lines, ask Gemini to "generate only the changed methods" to avoid the delimiter-dropping issue.B. E0282: Type Inference FailureRust is smart, but it can't read minds.$$\text{If variable } x \text{ is ambiguous, } x.abs() \text{ fails because the compiler doesn't know if } x \in \mathbb{Z} \text{ or } x \in \mathbb{R}$$In your code: if cx.abs() > 1000. Gemini didn't know if cx was an i32, f32, or f64.The Fix: Always write let cx: f32 = ... or 1000.0_f32.C. E0382: The "Move" ErrorIn Rust, once you send something into a thread::spawn(move || ... ), it is gone.Your Error: You tried to use stream_clone in two different threads.The Fix: You need to clone the handle for each thread:Rustlet mut stream_for_thread = stream.try_clone()?;
thread::spawn(move || { /* use stream_for_thread */ });